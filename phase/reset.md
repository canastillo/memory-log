---
cover: ../.gitbook/assets/reset-your-brain-1280x720 (1).jpeg
coverY: -1.4238042269188043
layout: editorial
---

# Press button to reset

I don't even know where to start.

Week by week, I've been making a log of what I've been learning throughout the month. Yet, there are things that were beyond the weekly lectures and that are part of the person and professional I've been turning into after this first phase.

This is all of it.

## Lightning talks. Long struggle <a href="#lightning_talks" id="lightning_talks"></a>

This was the first challenge. It isn't over yet but I think I'm getting better at it.&#x20;

With each talk, of course I've been learning technical concepts about the topics I explained: origin of algorithms, similitudes between Bellman-Ford and Dijkstra algorithms, graphs, computer architectures and Von Neumann.

But I also learned about the importance of self-organization, how critical it is the ability to take fast decisions and how it doesn't matter if you don't know a topic, but how fast you learn it, as well as being open to sharing with others what you have, even if it's just a little.

![It takes by far more time preparing the talk before and recovering from the talk after than giving the actual talk](<../.gitbook/assets/image (8).png>)

## Be a mentee <a href="#mentors" id="mentors"></a>

I'm new to having mentors. It was mentioned during the first week, in the conference about _Apprenticeship Patterns_, and in the _Passionate Programmer_ book. It seemed as **something super important when becoming a software engineer** (also useful in any field I guess) but I had never heard of it, until I started this program.

I got two mentors (they receive these essays every week but Idk if they read them lol), and I've learned a lot from them.

About how teams work, the projects they are working on, pair programming, a little about accessibility, about tools that frontend engineers use, the importance of taking breaks and about the apprenticeship itself.

They also have heard all of my LTs and gave me super valuable feedback. TYSM, u r awesome.

![](<../.gitbook/assets/image (10).png>)

## Thanks, Barb <a href="#learning_to_learn" id="learning_to_learn"></a>

I have no words for saying how cool this course was. I learned a lot about the brain, the memory, procrastination, sleep, habits, how to tackle a test and super useful testimonials.

I learned this concept of chunking, the four slots of working memory, tricks like spaced repetition and recall. **It is better to build knowledge** (and chunks) **little by little**, day by day, rather than all together, cramped, for two hours straight.

We also can happen to make mistakes that fool our mind into believing that we are learning, the called **illusions of competence**, like re-reading or highlighting every single word, instead of taking notes, writing side notes in our books or trying to recall what we can after finishing studying a new concept.

From all this stuff, the tips that I consider the most valuables for me are:

* To **take breaks** - get into the **diffuse mode**!
* Eat your **frogs first** - once the blocker is out of the way, **everything else is easier**

However, probably my favorite video was _Change your thoughts. Change your life._ This because of two super important points which I extremely agree with and that are mentioned here:

* **Taking responsibility for your own learning** is one of the most important things you can do.
* **Take pride in who you are.** Especially, in the qualities that make you **different**.

![I'm never forgetting you :c](<../.gitbook/assets/image (5).png>)

I'll never just thank this woman enough.

Here you can check out my Coursera profile: [https://www.coursera.org/user/0c0e8408792153fb9d827d6f5839f442](https://www.coursera.org/user/0c0e8408792153fb9d827d6f5839f442)

Anyway, I'm leaving a screenshot of my profile just in case you cannot see my achievements.

![](<../.gitbook/assets/image (9).png>)

## Hidden language of a passionate programmer <a href="#books" id="books"></a>

(I'm sorry, I couldn't think of anything better.)

You got no idea how I struggle trying to read books.

I mean, starting is not the problem. That's easy. The problem is to finish. I'm more of a movies person.

Anyway, here you got me, having to read two books in a month. It was quite a challenge. Mainly 'cause I left the biggest one at the end (not a smart decision). But I certainly learned a LOT.

### Code don't cut it anymore <a href="#passionate" id="passionate"></a>

I started with the _Passionate Programmer_ by Chad Fowler. The fact that Chad is all the time comparing his software career with his music career as a saxophonist helped me enjoy the book. As a music lover I appreciate this. I also liked how he didn't only speak but **suggested tips on how you could take action** at the end of each chapter.

What I take from this book is this idea of seeing your career as a business and how important it is to invest in it, to **invest in you**. I think my favorite part was the one talking about how it is not only important to be a good coder but to have an **excellent understanding of the business**. That's when **one can truly add value** to the domain we are working on.

The only complaint I have is I don't get to understand why the constant need to mention the offshore teams and the comparison with the onshore developers. Maybe I yet need to know more about developers' industry and context.

### How computers work <a href="#code" id="code"></a>

Now, about _Code: the Hidden Language of Computer Hardware and Software_ by Charles Petzold. I liked how it goes slowly building like, the context or the basic knowledge, **exactly what you need to know before taking the next step**.

It starts with the concept of _code_ taking the morse code as example. Then it goes into electricity and the telegraph, to then introduce the _relay,_ which basically turns a weak current into a strong one by flipping a switch, and so on.

It goes like, gradually showing you the next thing, the next invented technology needed to build an imaginary computer. I say imaginary but all that is written in the book is basically what we need (I guess? At least as a concept). It would be an interesting experiment to **actually build it**.

It even mentions the Von Neumann architecture, which was one of the topics I talked about during my Lightning Talks. Some of the information here helped me clarify some doubts before my talk (it wasn't clear to me why the Von Neumann bottleneck is caused).

From this point, I kinda got lost, reading about microprocessors and operating systems. It's definitely a book that I need to re-read more calmly and without a deadline on my shoulders.

## ~~Brain~~ Code jam <a href="#code_jam" id="code_jam"></a>

The other big challenge ~~(everything here is a big challenge send help)~~ was this thing where we had to solve four programming challenges in five languages. I actually mentioned a little about it at my post _Who do you trust?_

Let me add that it was difficult to have **everybody available at the same time** (we are still working on this thing of **async communication**) to explain each one of the solutions, but at the end we managed, and if anyone had a question, it was each one's responsibility to **ask the right person about it**.

Now_,_ I'd like to mention some of the insights we got at the Code Jam Discussion where we talked about the general solutions and the particular issues on the implementation for each language:

* It isn't always good to just translate code - **each language has its own especial features**
* When dealing with clients, we often have to make an effort to **get the essence of the problem**, and not to get distracted with details of the story
* We have to be careful with the **readability of the code** - we are a team, **not coding for ourselves only** (even ourselves may need explanations on our own code!)
* On meetings with the client, there can be a **tech person wanting to know what happens** - we have to be ready to explain
* **Each member** of the team has to able to **explain everything** in the project
* Haskell caused problems because of being functional and using recursivity, while Rust caused problems with the scope, variables passed by value and pointers



That's all for this phase folks!



